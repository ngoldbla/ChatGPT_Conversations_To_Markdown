<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Parley - ChatGPT Data Migration Tool</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        :root {
            --background: 40 25% 92%;
            --foreground: 30 10% 15%;
            --card: 36 33% 96%;
            --card-foreground: 30 10% 15%;
            --primary: 38 70% 45%;
            --primary-foreground: 36 33% 96%;
            --secondary: 30 15% 25%;
            --secondary-foreground: 36 33% 96%;
            --muted: 40 20% 85%;
            --muted-foreground: 30 10% 40%;
            --accent: 35 80% 55%;
            --accent-foreground: 30 10% 15%;
            --border: 30 15% 25%;
            --radius: .5rem;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: hsl(var(--background));
            color: hsl(var(--foreground));
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .parley-header {
            background: hsl(var(--secondary));
            border-bottom: 3px solid hsl(var(--primary));
        }

        .card {
            background: hsl(var(--card));
            border-radius: var(--radius);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border: 1px solid hsl(var(--border) / 0.3);
        }

        .card:hover {
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
        }

        .btn-primary {
            background: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            background: hsl(var(--accent));
        }

        .mode-card {
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .mode-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
        }

        .mode-card.selected {
            border-color: hsl(var(--primary));
            background: hsl(var(--primary) / 0.1);
        }

        .step-badge {
            background: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
        }

        .step-complete {
            background: hsl(var(--accent));
        }

        .progress-bar {
            background: hsl(var(--muted));
            overflow: hidden;
            border-radius: 9999px;
        }

        .progress-fill {
            background: linear-gradient(90deg, hsl(var(--primary)), hsl(var(--accent)));
            transition: width 0.3s ease;
        }

        .cherry-studio-card {
            background: linear-gradient(135deg, hsl(var(--primary) / 0.1) 0%, hsl(var(--accent) / 0.1) 100%);
            border: 2px solid hsl(var(--primary));
        }

        code {
            background: hsl(var(--muted));
            padding: 0.125rem 0.375rem;
            border-radius: 0.25rem;
            font-size: 0.875em;
        }
    </style>
</head>
<body>
    <div class="min-h-screen" x-data="converterApp()">

        <!-- Header -->
        <div class="parley-header text-white py-12">
            <div class="container mx-auto px-4 max-w-5xl">
                <h1 class="text-5xl font-bold mb-3">The Parley</h1>
                <p class="text-xl text-white/90">ChatGPT Data Migration Tool</p>
                <p class="text-sm text-white/70 mt-2">Export, Convert, and Import into Your BYOK Apps</p>
            </div>
        </div>

        <!-- Step Indicator -->
        <div class="container mx-auto px-4 max-w-5xl py-8">
            <div class="flex justify-between items-center">
                <div class="flex-1 text-center">
                    <div class="step-badge inline-block w-10 h-10 rounded-full flex items-center justify-center font-bold mb-2" :class="{'step-complete': completed}">1</div>
                    <p class="text-sm font-medium">Export from ChatGPT</p>
                </div>
                <div class="flex-1 h-1 bg-gray-300 mx-4" :class="{'bg-orange-500': processing || completed}"></div>
                <div class="flex-1 text-center">
                    <div class="step-badge inline-block w-10 h-10 rounded-full flex items-center justify-center font-bold mb-2" :class="{'step-complete': completed}">2</div>
                    <p class="text-sm font-medium">Convert to Markdown</p>
                </div>
                <div class="flex-1 h-1 bg-gray-300 mx-4" :class="{'bg-orange-500': completed}"></div>
                <div class="flex-1 text-center">
                    <div class="step-badge inline-block w-10 h-10 rounded-full flex items-center justify-center font-bold mb-2" :class="{'step-complete': completed}">3</div>
                    <p class="text-sm font-medium">Import to BYOK App</p>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="container mx-auto px-4 py-8 max-w-5xl">

            <!-- Step 1: ChatGPT Export Instructions -->
            <div class="card p-8 mb-8" x-show="!processing && !completed">
                <h2 class="text-3xl font-bold mb-6 flex items-center">
                    <span class="step-badge w-8 h-8 rounded-full inline-flex items-center justify-center mr-3 text-sm">1</span>
                    Export Your ChatGPT Data
                </h2>
                <div class="space-y-4 text-gray-700">
                    <p class="text-lg">First, you need to export your conversation data from ChatGPT:</p>
                    <ol class="list-decimal list-inside space-y-3 ml-4">
                        <li>Go to <a href="https://chatgpt.com/settings" target="_blank" class="text-orange-600 hover:text-orange-700 underline font-medium">ChatGPT Settings</a></li>
                        <li>Navigate to <strong>Data Controls</strong></li>
                        <li>Click <strong>"Export Data"</strong></li>
                        <li>Wait for an email from OpenAI (usually arrives within a few hours)</li>
                        <li>Click the download link in the email to receive your ZIP file</li>
                        <li>Save the ZIP file - <strong>do not extract it!</strong></li>
                    </ol>
                    <div class="bg-amber-50 border-l-4 border-amber-500 p-4 mt-4">
                        <p class="text-sm text-amber-800">
                            <strong>Note:</strong> The export includes all your conversations, images, audio messages, and DALL-E generations. The ZIP file may take several hours to generate depending on your conversation history.
                        </p>
                    </div>
                </div>
            </div>

            <!-- Step 2: Conversion -->
            <div x-show="!processing && !completed" class="space-y-8">
                <div class="card p-8">
                    <h2 class="text-3xl font-bold mb-6 flex items-center">
                        <span class="step-badge w-8 h-8 rounded-full inline-flex items-center justify-center mr-3 text-sm">2</span>
                        Convert to Markdown
                    </h2>

                    <!-- User Info -->
                    <div class="mb-6">
                        <label class="block text-sm font-medium mb-2">Your Name</label>
                        <input type="text" x-model="config.user_name" class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-orange-500 focus:border-transparent" placeholder="Enter your name">
                    </div>

                    <!-- Upload -->
                    <div class="mb-6">
                        <label class="block text-sm font-medium mb-2">Upload ChatGPT Export ZIP</label>
                        <div class="border-2 border-dashed border-gray-300 rounded-lg p-12 text-center hover:border-orange-400 transition-colors">
                            <input type="file" @change="handleFileUpload($event)" accept=".zip" class="hidden" id="zipFileInput">
                            <label for="zipFileInput" class="cursor-pointer">
                                <svg class="w-16 h-16 mx-auto mb-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                                </svg>
                                <p class="text-lg font-medium text-gray-700 mb-2">
                                    <span x-show="!zipFile">Click to upload ZIP file</span>
                                    <span x-show="zipFile" class="text-green-600 flex items-center justify-center">
                                        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                                        </svg>
                                        <span x-text="zipFile?.name"></span>
                                    </span>
                                </p>
                                <p class="text-sm text-gray-500">ChatGPT export ZIP file from Step 1</p>
                            </label>
                        </div>
                    </div>

                    <!-- Organization -->
                    <div class="mb-6">
                        <label class="block text-sm font-medium mb-3">Organization Mode</label>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div @click="config.organization_mode = 'flat'" :class="config.organization_mode === 'flat' ? 'selected' : ''" class="mode-card card border-2 p-4 relative">
                                <div class="absolute top-2 right-2">
                                    <span class="bg-purple-100 text-purple-800 text-xs px-2 py-1 rounded">Cherry Ready</span>
                                </div>
                                <h3 class="font-semibold mb-1">Flat (Cherry Import)</h3>
                                <p class="text-sm text-gray-600 mb-2">Single folder, date-prefixed filenames</p>
                                <p class="text-xs text-gray-500">Markdown only, no assets</p>
                            </div>
                            <div @click="config.organization_mode = 'category'" :class="config.organization_mode === 'category' ? 'selected' : ''" class="mode-card card border-2 p-4">
                                <h3 class="font-semibold mb-1">By Category</h3>
                                <p class="text-sm text-gray-600 mb-2">Starred/Archived/Regular</p>
                                <p class="text-xs text-gray-500">Power users</p>
                            </div>
                            <div @click="config.organization_mode = 'date'" :class="config.organization_mode === 'date' ? 'selected' : ''" class="mode-card card border-2 p-4">
                                <h3 class="font-semibold mb-1">By Date</h3>
                                <p class="text-sm text-gray-600 mb-2">Chronological folders</p>
                                <p class="text-xs text-gray-500">Timeline view</p>
                            </div>
                            <div @click="config.organization_mode = 'hybrid'" :class="config.organization_mode === 'hybrid' ? 'selected' : ''" class="mode-card card border-2 p-4 relative">
                                <div class="absolute top-2 right-2">
                                    <span class="bg-orange-100 text-orange-800 text-xs px-2 py-1 rounded">Recommended</span>
                                </div>
                                <h3 class="font-semibold mb-1">Hybrid</h3>
                                <p class="text-sm text-gray-600 mb-2">Category + Date</p>
                                <p class="text-xs text-gray-500">Best balance</p>
                            </div>
                        </div>
                    </div>

                    <!-- Options -->
                    <div class="mb-6">
                        <label class="block text-sm font-medium mb-3">Formatting Options</label>
                        <div class="space-y-3">
                            <label class="flex items-center space-x-3 cursor-pointer">
                                <input type="checkbox" x-model="config.use_frontmatter" class="w-5 h-5 text-orange-600 rounded">
                                <div><span class="font-medium">YAML Frontmatter</span><span class="text-sm text-gray-500 ml-2">(metadata headers)</span></div>
                            </label>
                            <label class="flex items-center space-x-3 cursor-pointer">
                                <input type="checkbox" x-model="config.use_collapsible_thinking" class="w-5 h-5 text-orange-600 rounded">
                                <div><span class="font-medium">Collapsible Thinking</span><span class="text-sm text-gray-500 ml-2">(HTML details for reasoning)</span></div>
                            </label>
                            <label class="flex items-center space-x-3 cursor-pointer">
                                <input type="checkbox" x-model="config.include_date" class="w-5 h-5 text-orange-600 rounded">
                                <div><span class="font-medium">Include Dates</span><span class="text-sm text-gray-500 ml-2">(show timestamps)</span></div>
                            </label>
                        </div>
                    </div>

                    <!-- Convert Button -->
                    <div class="text-center mt-8">
                        <button @click="convertConversations()" :disabled="!zipFile || !config.user_name" :class="!zipFile || !config.user_name ? 'opacity-50 cursor-not-allowed' : 'btn-primary cursor-pointer'" class="px-10 py-4 text-white font-semibold text-lg rounded-lg">
                            Convert to Markdown
                        </button>
                    </div>
                </div>
            </div>

            <!-- Processing -->
            <div x-show="processing" class="card p-8">
                <h2 class="text-3xl font-bold mb-6">Converting Conversations...</h2>
                <div class="space-y-6">
                    <div class="flex items-center space-x-3">
                        <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-orange-600"></div>
                        <span x-text="progressMessage" class="text-gray-700"></span>
                    </div>
                    <div class="progress-bar h-3">
                        <div class="progress-fill h-full" :style="`width: ${progress}%`"></div>
                    </div>
                    <div class="text-center">
                        <p class="text-lg font-medium"><span x-text="processedCount"></span> / <span x-text="totalCount"></span> conversations</p>
                        <p class="text-sm text-gray-500 mt-2">
                            <span x-text="audioFilesCopied"></span> audio,
                            <span x-text="videoFilesCopied"></span> video,
                            <span x-text="imageFilesCopied"></span> images,
                            <span x-text="dalleFilesCopied"></span> DALL-E
                        </p>
                    </div>
                </div>
            </div>

            <!-- Complete -->
            <div x-show="completed" class="space-y-8">
                <!-- Success Message -->
                <div class="card p-8 text-center">
                    <div class="inline-flex items-center justify-center w-20 h-20 rounded-full bg-green-100 mb-6">
                        <svg class="w-12 h-12 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                    </div>
                    <h2 class="text-3xl font-bold mb-4">Conversion Complete!</h2>
                    <p class="text-gray-600 mb-2">Your markdown files are ready for download</p>
                    <p class="text-sm text-purple-600 mb-8" x-show="config.organization_mode === 'flat'">
                        ‚ú® Flat file structure with date-prefixed filenames - ready for Cherry import!
                    </p>

                    <button @click="downloadZip()" class="btn-primary px-10 py-4 font-semibold rounded-lg mb-6 inline-flex items-center space-x-2">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                        </svg>
                        <span>Download Markdown Files</span>
                    </button>

                    <div class="bg-orange-50 rounded-lg p-6 text-left max-w-md mx-auto border border-orange-200">
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between"><span class="text-gray-600">Conversations:</span><span class="font-semibold" x-text="totalCount"></span></div>
                            <div class="flex justify-between"><span class="text-gray-600">Organization:</span><span class="font-semibold uppercase" x-text="config.organization_mode"></span></div>
                            <template x-if="config.organization_mode !== 'flat'">
                                <div>
                                    <div class="flex justify-between"><span class="text-gray-600">Audio:</span><span class="font-semibold" x-text="audioFilesCopied"></span></div>
                                    <div class="flex justify-between"><span class="text-gray-600">Video:</span><span class="font-semibold" x-text="videoFilesCopied"></span></div>
                                    <div class="flex justify-between"><span class="text-gray-600">Images:</span><span class="font-semibold" x-text="imageFilesCopied"></span></div>
                                    <div class="flex justify-between"><span class="text-gray-600">DALL-E:</span><span class="font-semibold" x-text="dalleFilesCopied"></span></div>
                                </div>
                            </template>
                            <template x-if="config.organization_mode === 'flat'">
                                <div class="flex justify-between"><span class="text-gray-600">Format:</span><span class="font-semibold text-purple-600">Markdown Only</span></div>
                            </template>
                        </div>
                    </div>

                    <button @click="reset()" class="mt-6 px-6 py-2 bg-white hover:bg-gray-50 text-gray-800 font-medium rounded-lg border-2 border-gray-300 hover:border-orange-400 transition-all">
                        Convert Another Export
                    </button>
                </div>

                <!-- Step 3: Import Instructions -->
                <div class="cherry-studio-card p-8 rounded-lg">
                    <h2 class="text-3xl font-bold mb-6 flex items-center">
                        <span class="step-badge step-complete w-8 h-8 rounded-full inline-flex items-center justify-center mr-3 text-sm">3</span>
                        Import into Your BYOK App
                    </h2>

                    <div class="space-y-6">
                        <!-- Cherry Studio Instructions -->
                        <div class="bg-white rounded-lg p-6 shadow-sm">
                            <h3 class="text-2xl font-bold mb-4 text-orange-700">Cherry Studio Knowledge Base Setup</h3>

                            <div class="space-y-6">
                                <!-- Extract Files -->
                                <div>
                                    <h4 class="font-semibold text-lg mb-2">1. Extract Your Markdown Files</h4>
                                    <p class="text-gray-700 mb-2">Extract the ZIP file you just downloaded and locate the <code>MarkdownFiles</code> folder.</p>
                                    <template x-if="config.organization_mode === 'flat'">
                                        <div class="bg-purple-50 border-l-4 border-purple-500 p-3 text-sm">
                                            <p class="text-purple-800">
                                                <strong>üí° Flat File Structure:</strong> All markdown files are in a single folder with date-prefixed filenames (YYYY-MM-DD_Title.md), making it easy to select all files in one gesture for import into Cherry.
                                            </p>
                                        </div>
                                    </template>
                                </div>

                                <!-- Setup OpenAI Embeddings -->
                                <div>
                                    <h4 class="font-semibold text-lg mb-2">2. Add OpenAI Embeddings Model</h4>
                                    <ol class="list-decimal list-inside space-y-2 ml-4 text-gray-700">
                                        <li>Open Cherry Studio</li>
                                        <li>Go to <strong>Settings</strong> ‚Üí <strong>Models</strong></li>
                                        <li>Add a new model with these settings:
                                            <ul class="list-disc list-inside ml-6 mt-2 space-y-1 text-sm">
                                                <li><strong>Provider:</strong> OpenAI</li>
                                                <li><strong>Model Name:</strong> <code>text-embedding-3-large</code></li>
                                                <li><strong>API Key:</strong> Your OpenAI API key</li>
                                            </ul>
                                        </li>
                                        <li>Save the model configuration</li>
                                    </ol>
                                </div>

                                <!-- Create Knowledge Base -->
                                <div>
                                    <h4 class="font-semibold text-lg mb-2">3. Create Knowledge Base</h4>
                                    <ol class="list-decimal list-inside space-y-2 ml-4 text-gray-700">
                                        <li>In Cherry Studio, navigate to <strong>Knowledge Base</strong></li>
                                        <li>Click <strong>"Create New Knowledge Base"</strong></li>
                                        <li>Give it a name (e.g., "My ChatGPT Conversations")</li>
                                        <li>Select <strong>MinerU</strong> as the document processor</li>
                                        <li>Select <strong>text-embedding-3-large</strong> as the embeddings model</li>
                                        <li>Import your markdown files from the <code>MarkdownFiles</code> folder</li>
                                        <li>Wait for processing to complete (this may take some time depending on the number of conversations)</li>
                                    </ol>
                                </div>

                                <!-- Use Knowledge Base -->
                                <div>
                                    <h4 class="font-semibold text-lg mb-2">4. Use Your Knowledge Base</h4>
                                    <p class="text-gray-700 mb-2">Once processing is complete, you can:</p>
                                    <ul class="list-disc list-inside ml-4 space-y-1 text-gray-700">
                                        <li>Search through all your ChatGPT conversations</li>
                                        <li>Ask questions about past conversations</li>
                                        <li>Get AI-powered insights from your conversation history</li>
                                        <li>Reference specific conversations in new chats</li>
                                    </ul>
                                </div>

                                <!-- Learn More -->
                                <div class="bg-blue-50 border-l-4 border-blue-500 p-4">
                                    <p class="text-sm text-blue-800">
                                        <strong>Learn More:</strong> For detailed instructions and troubleshooting, visit the
                                        <a href="https://docs.cherry-ai.com/docs/en-us/knowledge-base/knowledge-base" target="_blank" class="underline hover:text-blue-900">Cherry Studio Knowledge Base Documentation</a>
                                    </p>
                                </div>
                            </div>
                        </div>

                        <!-- Other BYOK Apps -->
                        <div class="bg-white rounded-lg p-6 shadow-sm">
                            <h3 class="text-xl font-bold mb-4">Other BYOK Apps</h3>
                            <p class="text-gray-700 mb-4">The Parley outputs standard markdown files that work with any BYOK (Bring Your Own Key) application that supports:</p>
                            <ul class="list-disc list-inside ml-4 space-y-2 text-gray-700">
                                <li>Markdown document import</li>
                                <li>Knowledge base / RAG functionality</li>
                                <li>Custom embeddings models</li>
                            </ul>
                            <p class="text-sm text-gray-600 mt-4">
                                Check your app's documentation for specific import instructions.
                            </p>
                        </div>
                    </div>
                </div>
            </div>

        </div>

        <!-- Footer -->
        <div class="text-center py-8 text-gray-500 text-sm border-t border-gray-300 mt-12">
            <p class="font-medium">üîí Privacy First: All processing happens in your browser</p>
            <p class="mt-1">Your conversations never leave your computer</p>
            <p class="mt-2 text-xs">The Parley is open source and free to use</p>
        </div>
    </div>

    <script>
        function converterApp() {
            return {
                config: {
                    user_name: '',
                    assistant_name: 'ChatGPT',
                    organization_mode: 'hybrid',
                    use_frontmatter: true,
                    use_collapsible_thinking: true,
                    include_date: true,
                    starred_folder: 'Starred',
                    archived_folder: 'Archived',
                    regular_folder: 'Regular'
                },
                zipFile: null,
                processing: false,
                completed: false,
                progress: 0,
                progressMessage: '',
                processedCount: 0,
                totalCount: 0,
                audioFilesCopied: 0,
                imageFilesCopied: 0,
                dalleFilesCopied: 0,
                videoFilesCopied: 0,
                urlsExtracted: 0,
                citationsFound: 0,
                outputZip: null,

                async handleFileUpload(event) {
                    this.zipFile = event.target.files[0];
                    if (this.zipFile) console.log('ZIP loaded:', this.zipFile.name);
                },

                // ON-DEMAND SEARCH: Find file starting with fileId (Python glob-style)
                findAssetFile(fileId, zipContent) {
                    if (!fileId) return null;

                    const allFiles = Object.keys(zipContent.files);

                    // Search patterns in priority order (matching Python)
                    const searchStrategies = [
                        // 1. DALL-E images: dalle-generations/{fileId}-*
                        {
                            test: (path) => path.toLowerCase().includes('dalle-generations') &&
                                           path.includes(fileId),
                            type: 'dalle'
                        },
                        // 2. Audio files: **/audio/{fileId}-*
                        {
                            test: (path) => path.toLowerCase().includes('/audio/') &&
                                           path.includes(fileId),
                            type: 'audio'
                        },
                        // 3. User files: user-*/{fileId}*
                        {
                            test: (path) => path.toLowerCase().includes('user-') &&
                                           path.includes(fileId),
                            type: 'image'
                        },
                        // 4. Root images: {fileId}-* (anywhere)
                        {
                            test: (path) => path.includes(fileId),
                            type: 'image'
                        }
                    ];

                    // Try each search strategy in order
                    for (const strategy of searchStrategies) {
                        for (const fullPath of allFiles) {
                            // Skip directories
                            if (fullPath.endsWith('/')) continue;

                            // Check if file matches this strategy
                            if (strategy.test(fullPath)) {
                                const filename = fullPath.substring(fullPath.lastIndexOf('/') + 1);
                                return { path: fullPath, type: strategy.type };
                            }
                        }
                    }

                    // File not found - this is normal for deleted/web-only assets
                    return null;
                },

                async convertConversations() {
                    if (!this.zipFile || !this.config.user_name) {
                        alert('Please complete all required fields');
                        return;
                    }

                    this.processing = true;
                    this.progress = 0;

                    try {
                        console.log('\n=== STARTING CONVERSION ===\n');

                        const zip = new JSZip();
                        const zipContent = await zip.loadAsync(this.zipFile);

                        // Using on-demand file search (Python-style) - no pre-indexing needed

                        const conversationsFile = zipContent.file('conversations.json');
                        if (!conversationsFile) throw new Error('conversations.json not found');

                        const conversations = JSON.parse(await conversationsFile.async('string'));
                        this.totalCount = conversations.length;
                        this.processedCount = 0;
                        this.audioFilesCopied = 0;
                        this.imageFilesCopied = 0;
                        this.dalleFilesCopied = 0;
                        this.videoFilesCopied = 0;
                        this.urlsExtracted = 0;
                        this.citationsFound = 0;

                        this.outputZip = new JSZip();
                        const markdownFolder = this.outputZip.folder('MarkdownFiles');
                        const assetsFolder = markdownFolder.folder('Assets');
                        const imagesFolder = assetsFolder.folder('Images');
                        const audioFolder = assetsFolder.folder('Audio');
                        const videoFolder = assetsFolder.folder('Video');
                        const dalleFolder = assetsFolder.folder('DALLE');

                        this.progressMessage = 'Converting conversations...';

                        for (const conv of conversations) {
                            try {
                                const title = conv.title || 'Untitled';
                                this.progressMessage = `Converting: ${title.substring(0, 50)}${title.length > 50 ? '...' : ''}`;
                                const markdown = await this.generateMarkdown(conv, zipContent, imagesFolder, audioFolder, videoFolder, dalleFolder);
                                this.outputZip.file(this.getConversationPath(conv), markdown);
                            } catch (convError) {
                                console.error(`Error processing conversation "${conv.title || 'Untitled'}":`, convError);
                                // Continue with next conversation instead of failing completely
                            }
                            this.processedCount++;
                            this.progress = Math.round((this.processedCount / this.totalCount) * 100);
                        }

                        this.processing = false;
                        this.completed = true;
                        console.log('\n=== CONVERSION COMPLETE ===');
                        console.log(`‚úÖ Processed: ${this.totalCount} conversations`);
                        console.log(`üìÅ Assets copied:`);
                        console.log(`   - Images: ${this.imageFilesCopied}`);
                        console.log(`   - DALL-E: ${this.dalleFilesCopied}`);
                        console.log(`   - Audio: ${this.audioFilesCopied}`);
                        console.log(`   - Video: ${this.videoFilesCopied}`);
                        console.log(`üîó URLs extracted: ${this.urlsExtracted}`);
                        console.log(`\nüíæ Ready to download!\n`);

                    } catch (error) {
                        console.error('ERROR:', error);
                        let errorMessage = 'An error occurred during conversion';

                        if (error.message.includes('conversations.json')) {
                            errorMessage = 'conversations.json not found in the ZIP file. Please make sure you uploaded a valid ChatGPT export.';
                        } else if (error.message.includes('JSON')) {
                            errorMessage = 'Invalid JSON format in conversations.json. The file may be corrupted.';
                        } else {
                            errorMessage = `Error: ${error.message}`;
                        }

                        alert(errorMessage);
                        this.processing = false;
                    }
                },

                async generateMarkdown(conv, zipContent, imagesFolder, audioFolder, videoFolder, dalleFolder) {
                    let md = '';
                    const title = conv.title || 'Untitled';

                    // Get conversation path for relative asset links
                    const conversationPath = this.getConversationPath(conv);

                    if (this.config.use_frontmatter) {
                        md += '---\n';
                        md += `title: "${title}"\n`;
                        if (conv.create_time) md += `created: ${this.formatTimestamp(conv.create_time)}\n`;
                        if (conv.update_time) md += `updated: ${this.formatTimestamp(conv.update_time)}\n`;
                        md += 'tags:\n  - chatgpt\n  - conversation\n---\n\n';
                    }

                    md += `# ${title}\n\n`;
                    if (this.config.include_date && conv.create_time) {
                        md += `<sub>${this.formatDate(conv.create_time)}</sub>\n\n`;
                    }
                    md += '---\n\n';

                    const messages = [];
                    for (const key in conv.mapping || {}) {
                        const item = conv.mapping[key];
                        if (item.message && !item.message.metadata?.is_visually_hidden_from_conversation) {
                            messages.push(item.message);
                        }
                    }
                    messages.sort((a, b) => (a.create_time || 0) - (b.create_time || 0));

                    for (const msg of messages) {
                        if (msg.author?.role === 'system') continue;
                        const author = this.getAuthorName(msg);
                        const content = await this.getMessageContent(msg, zipContent, imagesFolder, audioFolder, videoFolder, dalleFolder, conversationPath);
                        if (content.trim()) md += `**${author}**:\n\n${content}\n\n`;
                    }

                    return md;
                },

                getAuthorName(msg) {
                    const role = msg.author?.role;
                    const content = msg.content || {};
                    const recipient = msg.recipient || '';
                    const contentType = content.content_type || '';

                    // User messages
                    if (role === 'user') return this.config.user_name;

                    // Tool messages
                    if (role === 'tool') return `Tool (${msg.author?.name || 'tool'})`;

                    // System context messages
                    if (contentType === 'user_editable_context') return 'System (context)';

                    // Assistant messages with special types
                    const baseName = this.config.assistant_name;

                    // Tool calls/execution (code content with specific recipients)
                    if (contentType === 'code') {
                        if (recipient === 'web') return `${baseName} (tool call)`;
                        if (recipient === 'web.run') return `${baseName} (tool execution)`;
                    }

                    // Thinking/reasoning
                    if (content.thoughts) return `${baseName} (thinking)`;
                    if (contentType === 'reasoning_recap') return `${baseName} (reasoning summary)`;

                    return baseName;
                },

                async getMessageContent(msg, zipContent, imagesFolder, audioFolder, videoFolder, dalleFolder, conversationPath) {
                    const content = msg.content || {};
                    const metadata = msg.metadata || {};
                    const contentType = content.content_type || '';
                    const role = msg.author?.role;

                    // Handle tool messages - wrap in collapsible section
                    if (role === 'tool') {
                        const toolName = msg.author?.name || 'tool';

                        // Process parts first (DALL-E images are in tool message parts!)
                        let processedContent = '';
                        if (content.parts) {
                            processedContent = await this.processParts(content.parts, zipContent, imagesFolder, audioFolder, videoFolder, dalleFolder, conversationPath);
                        }

                        // Add text content if present
                        const toolText = content.text || content.result || '';
                        const fullContent = [processedContent, toolText].filter(s => s.trim()).join('\n\n');

                        if (this.config.use_collapsible_thinking && fullContent) {
                            return `<details><summary>üîß Tool: ${toolName}</summary>\n\n${fullContent}\n\n</details>`;
                        }
                        return fullContent;
                    }

                    // Handle multimodal parts (text, images, audio, video)
                    if (content.parts) {
                        return await this.processParts(content.parts, zipContent, imagesFolder, audioFolder, videoFolder, dalleFolder, conversationPath);
                    }

                    // Handle user context messages
                    if (contentType === 'user_editable_context') {
                        const profile = content.user_profile || '';
                        const instructions = content.user_instructions || '';
                        let text = '*User Context*:\n';
                        if (profile) text += `${profile}\n`;
                        if (instructions) text += `${instructions}\n`;
                        if (this.config.use_collapsible_thinking) {
                            return `<details><summary>üë§ User Context</summary>\n\n${text.trim()}\n\n</details>`;
                        }
                        return text.trim();
                    }

                    // Handle reasoning recap
                    if (contentType === 'reasoning_recap') {
                        const recap = content.content || 'Reasoning completed';
                        if (this.config.use_collapsible_thinking) {
                            return `<details><summary>üìä Reasoning Summary</summary>\n\n${recap}\n\n</details>`;
                        }
                        return recap;
                    }

                    // Handle internal thinking/thoughts
                    if (content.thoughts) {
                        let text = '';
                        for (const t of content.thoughts) {
                            if (t.summary && t.content) text += `**${t.summary}**: ${t.content}\n\n`;
                        }
                        if (this.config.use_collapsible_thinking && text) {
                            return `<details><summary>üí≠ Internal Reasoning</summary>\n\n${text}</details>`;
                        }
                        return text;
                    }

                    // Handle code content
                    if (contentType === 'code') {
                        return '```\n' + (content.text || '') + '\n```';
                    }

                    // Handle regular text
                    if (content.text) return content.text;
                    if (content.result) return content.result;

                    return '';
                },

                async processParts(parts, zipContent, imagesFolder, audioFolder, videoFolder, dalleFolder, conversationPath) {
                    if (!parts?.length) return '';
                    const content = [];

                    // Skip all asset processing if in flat mode (Cherry import mode)
                    const skipAssets = this.config.organization_mode === 'flat';

                    for (const part of parts) {
                        if (typeof part === 'string') {
                            // Convert URLs to markdown links
                            const urlRegex = /(https?:\/\/[^\s]+)/g;
                            let text = part;
                            text = text.replace(urlRegex, (url) => {
                                this.urlsExtracted++;
                                return `[üîó Link](${url})`;
                            });
                            content.push(text);
                        }
                        else if (typeof part === 'object') {
                            const type = part.content_type;

                            // Handle image assets
                            if (type === 'image_asset_pointer') {
                                if (skipAssets) continue; // Skip in flat mode

                                const fileId = this.extractFileId(part.asset_pointer || '');
                                if (fileId) {
                                    const result = await this.copyAssetFile(fileId, zipContent, imagesFolder, dalleFolder, null);
                                    if (result) {
                                        const folder = result.type === 'dalle' ? 'DALLE' : 'Images';
                                        const relativePath = this.getRelativeAssetPath(conversationPath, folder);
                                        content.push(`![Image](${relativePath}${result.filename})`);
                                    }
                                }
                            }
                            // Handle audio/video assets
                            else if (type === 'audio_asset_pointer' || type === 'real_time_user_audio_video_asset_pointer') {
                                if (skipAssets) continue; // Skip in flat mode

                                // Process audio
                                let audioPointer = null, audioDuration = null;
                                if (type === 'audio_asset_pointer') {
                                    audioPointer = part.asset_pointer || '';
                                    const meta = part.metadata || {};
                                    audioDuration = (meta.end || 0) - (meta.start || 0);
                                } else if (type === 'real_time_user_audio_video_asset_pointer') {
                                    const audioPtr = part.audio_asset_pointer || {};
                                    audioPointer = audioPtr.asset_pointer || '';
                                    const meta = audioPtr.metadata || {};
                                    audioDuration = (meta.end || 0) - (meta.start || 0);
                                }

                                if (audioPointer) {
                                    const fileId = this.extractFileId(audioPointer);
                                    if (fileId) {
                                        const result = await this.copyAssetFile(fileId, zipContent, audioFolder, null, null);
                                        const durText = audioDuration ? ` (${audioDuration.toFixed(1)}s)` : '';
                                        if (result) {
                                            const relativePath = this.getRelativeAssetPath(conversationPath, 'Audio');
                                            content.push(`[üéµ Audio${durText}](${relativePath}${result.filename})`);
                                        } else {
                                            content.push(`*[Audio${durText}]*`);
                                        }
                                    }
                                }

                                // Process video (if present in real_time_user_audio_video_asset_pointer)
                                if (type === 'real_time_user_audio_video_asset_pointer') {
                                    const videoPtr = part.video_asset_pointer || {};
                                    const videoPointer = videoPtr.asset_pointer || '';
                                    if (videoPointer) {
                                        const fileId = this.extractFileId(videoPointer);
                                        if (fileId) {
                                            const result = await this.copyAssetFile(fileId, zipContent, null, null, videoFolder);
                                            if (result) {
                                                const relativePath = this.getRelativeAssetPath(conversationPath, 'Video');
                                                content.push(`[üé¨ Video](${relativePath}${result.filename})`);
                                            }
                                        }
                                    }
                                }
                            }
                            else if (part.text) {
                                // Convert URLs to markdown links
                                const urlRegex = /(https?:\/\/[^\s]+)/g;
                                let text = part.text;
                                text = text.replace(urlRegex, (url) => {
                                    this.urlsExtracted++;
                                    return `[üîó Link](${url})`;
                                });
                                content.push(text);
                            }
                        }
                    }
                    return content.join('\n');
                },

                extractFileId(assetPointer) {
                    if (!assetPointer) return null;
                    let match = assetPointer.match(/file-service:\/\/(file-[a-zA-Z0-9_-]+)/);
                    if (match) return match[1];
                    match = assetPointer.match(/sediment:\/\/file_([0-9a-fA-F]+)/);
                    if (match) return `file_${match[1]}`;
                    return null;
                },

                async copyAssetFile(fileId, zipContent, imagesFolder, dalleFolder, videoFolder) {
                    // Search for file on-demand (Python-style)
                    const fileInfo = this.findAssetFile(fileId, zipContent);
                    if (!fileInfo) {
                        // File not found - normal for deleted/web-only content
                        return null;
                    }

                    try {
                        const file = zipContent.file(fileInfo.path);
                        if (!file) {
                            console.warn('File not in ZIP:', fileInfo.path);
                            return null;
                        }

                        const data = await file.async('blob');
                        const filename = fileInfo.path.split('/').pop();

                        // Determine which folder to use based on file type
                        let folder = null;
                        if (fileInfo.type === 'dalle' && dalleFolder) {
                            folder = dalleFolder;
                        } else if (fileInfo.type === 'video' && videoFolder) {
                            folder = videoFolder;
                        } else if (fileInfo.type === 'audio') {
                            // Audio always uses the first non-null folder passed (should be audioFolder)
                            folder = imagesFolder || dalleFolder || videoFolder;
                        } else {
                            // Images use imagesFolder
                            folder = imagesFolder;
                        }

                        if (!folder) {
                            console.error('No folder specified for file type:', fileInfo.type);
                            return null;
                        }

                        folder.file(filename, data);

                        // Update counters
                        if (fileInfo.type === 'audio') this.audioFilesCopied++;
                        else if (fileInfo.type === 'video') this.videoFilesCopied++;
                        else if (fileInfo.type === 'dalle') this.dalleFilesCopied++;
                        else this.imageFilesCopied++;

                        // Return both filename and type
                        return { filename, type: fileInfo.type };
                    } catch (error) {
                        console.error('Copy error for', fileId, ':', error.message);
                        return null;
                    }
                },

                getConversationPath(conv) {
                    const title = (conv.title || 'Untitled').replace(/[^a-z0-9_\- ]/gi, '').trim() || 'conversation';
                    let filename;

                    // Include date prefix in flat mode for Cherry import
                    if (this.config.organization_mode === 'flat' && conv.create_time) {
                        const date = new Date(conv.create_time * 1000);
                        const year = date.getFullYear();
                        const month = String(date.getMonth() + 1).padStart(2, '0');
                        const day = String(date.getDate()).padStart(2, '0');
                        filename = `${year}-${month}-${day}_${title.replace(/\s+/g, '_')}.md`;
                    } else {
                        filename = `${title.replace(/\s+/g, '_')}.md`;
                    }

                    const mode = this.config.organization_mode;
                    const base = 'MarkdownFiles/';
                    let category = null;
                    if (conv.is_starred) category = this.config.starred_folder;
                    else if (conv.is_archived) category = this.config.archived_folder;
                    if (mode === 'flat') return base + filename;
                    if (mode === 'category') return category ? `${base}${category}/${filename}` : `${base}${this.config.regular_folder}/${filename}`;
                    if (mode === 'date') return `${base}${this.getDateFolder(conv)}/${filename}`;
                    if (mode === 'hybrid') {
                        const date = this.getDateFolder(conv);
                        return category ? `${base}${category}/${date}/${filename}` : `${base}${this.config.regular_folder}/${date}/${filename}`;
                    }
                    return base + filename;
                },

                // Calculate correct relative path from markdown file to asset folder
                getRelativeAssetPath(conversationPath, assetFolder) {
                    // Count depth: MarkdownFiles/Starred/2025/01-January/file.md
                    // Split and subtract 2 (base + filename)
                    const parts = conversationPath.split('/');
                    const depth = parts.length - 2; // -1 for base "MarkdownFiles", -1 for filename

                    // Build relative path: ../../../Assets/Images/
                    const prefix = depth > 0 ? '../'.repeat(depth) : '';
                    return `${prefix}Assets/${assetFolder}/`;
                },

                getDateFolder(conv) {
                    if (!conv.create_time) return 'Unknown';
                    const d = new Date(conv.create_time * 1000);
                    const month = String(d.getMonth() + 1).padStart(2, '0');
                    const monthName = d.toLocaleString('default', { month: 'long' });
                    return `${d.getFullYear()}/${month}-${monthName}`;
                },

                formatTimestamp(ts) {
                    return new Date(ts * 1000).toISOString().replace('T', ' ').substring(0, 19);
                },

                formatDate(ts) {
                    const d = new Date(ts * 1000);
                    return `${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}-${d.getFullYear()}`;
                },

                async downloadZip() {
                    const blob = await this.outputZip.generateAsync({ type: 'blob' });
                    const now = new Date();
                    const month = now.toLocaleString('default', { month: 'long' });
                    const filename = `${month}_${now.getDate()}_${now.getFullYear()}_chatgpt_parley_export.zip`;
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    link.click();
                    URL.revokeObjectURL(url);
                },

                reset() {
                    Object.assign(this, {
                        zipFile: null, processing: false, completed: false, progress: 0,
                        progressMessage: '', processedCount: 0, totalCount: 0,
                        audioFilesCopied: 0, imageFilesCopied: 0, dalleFilesCopied: 0,
                        videoFilesCopied: 0, urlsExtracted: 0, citationsFound: 0,
                        outputZip: null
                    });
                    document.getElementById('zipFileInput').value = '';
                }
            }
        }
    </script>
</body>
</html>
